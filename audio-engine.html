/* ====== JAILEX AUDIO ENGINE (BLUEPRINT EDITION) ====== */

// 1. STATE & CONFIG
let queue = [];
let isPlaying = true;
let isMuted = false;
let isSpeaking = false; // Vanilla JS equivalent of isSpeakingRef
let audioEnabled = false;

let voices = [];
let kickVoiceName = "";
let timerVoiceName = "";
let volume = 1;
let rate = 1;
let pitch = 1;

// 2. BOT FILTERING (From Blueprint)
const KICK_BOTS = [
  "botrix", "kickbot", "kick", "streamelements", "nightbot", "moobot",
  "fossabot", "wizebot", "deepbot", "coebot", "phantombot", "ankhbot",
  "vivbot", "streamlabs", "cloudbot", "stay_hydrated_bot", "restreambot",
  "sery_bot", "commanderroot", "lurxx", "electricalskateboard",
  "electricallongboard", "alizeepathfinder", "virgoproz", "creatisbot",
  "slocool", "p0lizei_", "lolrankbot", "0ax2", "thepositivebot",
  "communityshowcase",
];

const isBot = (username) => {
  const lowerUsername = username.toLowerCase().trim();
  if (KICK_BOTS.includes(lowerUsername)) return true;
  if (lowerUsername.endsWith("bot") || lowerUsername.endsWith("_bot") || lowerUsername.includes("bot_")) {
    return true;
  }
  return false;
};

/* ====== VOICE LOADER ====== */
function initVoices() {
  voices = speechSynthesis.getVoices();
  if (voices.length === 0) {
    setTimeout(initVoices, 200);
    return;
  }
  
  const kSelect = document.getElementById("kickVoice");
  const tSelect = document.getElementById("timerVoice");

  if (kSelect && tSelect) {
    kSelect.innerHTML = "";
    tSelect.innerHTML = "";
    voices.forEach(v => {
      let opt = document.createElement("option");
      opt.value = v.name; opt.textContent = v.name;
      kSelect.appendChild(opt.cloneNode(true));
      tSelect.appendChild(opt.cloneNode(true));
    });
  }
}
speechSynthesis.onvoiceschanged = initVoices;
initVoices();

/* ====== THE FRONT DOOR (addMessage) ====== */
function addMessage(msg) {
  // 1. Bot Filtering
  if (isBot(msg.username)) {
    console.log("Ignored bot message from:", msg.username);
    return;
  }

  // 2. Update HUD Feed
  const log = document.getElementById("chatLog");
  if (log) {
    const div = document.createElement("div");
    div.className = "chat-line";
    const color = msg.platform === "kick" ? "#53fc18" : "#a970ff";
    div.innerHTML = `<span style="color:${color};font-weight:600">[${msg.platform.toUpperCase()}] ${msg.username}:</span> ${msg.message}`;
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
  }

  // 3. Add to Queue
  queue.push(msg);
  const qDisplay = document.getElementById("queueLen");
  if (qDisplay) qDisplay.textContent = queue.length;
}

/* ====== QUEUE PROCESSING (Every 100ms per Blueprint) ====== */
const processQueue = () => {
  // Don't process if paused, muted, already speaking, queue empty, or audio not enabled
  if (!audioEnabled || !isPlaying || isMuted || isSpeaking || queue.length === 0) {
    return;
  }

  // Get next message from queue
  const nextMessage = queue.shift();
  
  // Update UI Stats
  const qDisplay = document.getElementById("queueLen");
  const nowDisplay = document.getElementById("speakingNow");
  if (qDisplay) qDisplay.textContent = queue.length;
  if (nowDisplay) nowDisplay.textContent = nextMessage.username;

  isSpeaking = true;

  // Build text to speak
  const readUserCheck = document.getElementById("readUsername");
  const textToSpeak = (readUserCheck && readUserCheck.checked) 
    ? `${nextMessage.username} says: ${nextMessage.message}`
    : nextMessage.message;

  // Create utterance
  const utterance = new SpeechSynthesisUtterance(textToSpeak);
  utterance.volume = volume;
  utterance.rate = rate;
  utterance.pitch = pitch;
  
  // Select Voice
  const vId = (nextMessage.platform === "kick") ? "kickVoice" : "timerVoice";
  const vSelect = document.getElementById(vId);
  if (vSelect) {
    const voice = voices.find((v) => v.name === vSelect.value);
    if (voice) utterance.voice = voice;
  }

  // Completion Handlers
  utterance.onend = () => {
    isSpeaking = false;
    if (nowDisplay) nowDisplay.textContent = "None";
  };
  utterance.onerror = () => {
    isSpeaking = false;
    if (nowDisplay) nowDisplay.textContent = "None";
  };

  // Speak
  speechSynthesis.speak(utterance);
};

// Start the 100ms interval
setInterval(processQueue, 100);
