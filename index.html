/* ====== AUTO-LOAD SAVED CREDENTIALS ====== */
const savedKickID = localStorage.getItem('jx_kick_id');
const savedKickUser = localStorage.getItem('jx_kick_user');
const savedTwitchToken = localStorage.getItem('jx_twitch_token');

// Redirect protection: if they don't have a Kick ID, send them back to setup
if (!savedKickID) {
    alert("Missing Kick configuration! Redirecting to setup...");
    window.location.href = "/setup.html";
}

/* ====== CONFIG / STATE ====== */
let queue = [];
let isPlaying = true;
let isMuted = false;
let isSpeaking = false; // Vanilla JS equivalent of isSpeakingRef.current
let audioEnabled = false;

let voices = [];
let kickVoiceName = "";
let twitchVoiceName = ""; // Added for Twitch support in the blueprint
let timerVoiceName = "";
let volume = 1;
let rate = 1;
let pitch = 1;

let timers = []; 

// We are forcing browser TTS as requested by the blueprint core
let ttsEngine = "browser"; 

/* ====== ELEMENTS ====== */
const queueLen = document.getElementById("queueLen");
const speakingNow = document.getElementById("speakingNow");
const chatLog = document.getElementById("chatLog");

const enableAudioBtn = document.getElementById("enableAudioBtn");
const playPauseBtn = document.getElementById("playPauseBtn");
const muteBtn = document.getElementById("muteBtn");
const testTtsBtn = document.getElementById("testTtsBtn");
const testTimerBtn = document.getElementById("testTimerBtn");
const readUsernameBox = document.getElementById("readUsername");

const kickVoiceSelect = document.getElementById("kickVoice");
const timerVoiceSelect = document.getElementById("timerVoice");
const volumeSlider = document.getElementById("volume");
const rateSlider = document.getElementById("rate");
const pitchSlider = document.getElementById("pitch");

const timerMessageInput = document.getElementById("timerMessageInput");
const timerPresetSelect = document.getElementById("timerPresetSelect");
const customIntervalWrapper = document.getElementById("customIntervalWrapper");
const customIntervalInput = document.getElementById("customIntervalInput");
const addTimerBtn = document.getElementById("addTimerBtn");
const timersList = document.getElementById("timersList");
const timerError = document.getElementById("timerError");

// Connection UI Elements
const kickUsernameInput = document.getElementById("kickUsernameInput");
const kickStatusPill = document.getElementById("kickStatusPill");
const twitchUsernameInput = document.getElementById("twitchUsernameInput");
const twitchEnableCheckbox = document.getElementById("twitchEnableCheckbox");
const twitchStatusPill = document.getElementById("twitchStatusPill");
const twitchTokenInput = document.getElementById("twitchTokenInput");
const authWarning = document.getElementById("authWarning");

/* ====== INITIALIZE CONNECTIONS UI ====== */
kickUsernameInput.value = savedKickUser || "Unknown User";

if (savedTwitchToken) {
    twitchUsernameInput.value = "Authenticated via OAuth";
    twitchTokenInput.value = "••••••••••••••••••••••••";
    twitchStatusPill.textContent = "Connected (Auto)";
    twitchStatusPill.classList.remove("status-off");
    twitchStatusPill.classList.add("status-on");
} else {
    twitchUsernameInput.value = "Not Connected";
    twitchStatusPill.textContent = "Disconnected";
    if (authWarning) {
        authWarning.innerHTML = '<a href="/setup.html" style="color:#0020ff;">Click here to connect Twitch.</a>';
    }
}

/* ====== SIDEBAR TABS ====== */
document.querySelectorAll(".tab-button").forEach(btn => {
  btn.onclick = () => {
    document.querySelectorAll(".tab-button").forEach(b => b.classList.remove("active"));
    document.querySelectorAll(".tab-panel").forEach(p => p.classList.remove("active"));

    btn.classList.add("active");
    const targetId = btn.getAttribute("data-target");
    const panel = document.getElementById(targetId);
    if (panel) panel.classList.add("active");
  };
});

/* ====== VOICES (BROWSER TTS) ====== */
function loadVoices() {
  voices = speechSynthesis.getVoices();
  if (voices.length === 0) {
    setTimeout(loadVoices, 200);
    return;
  }

  kickVoiceSelect.innerHTML = "";
  timerVoiceSelect.innerHTML = "";

  voices.forEach(v => {
    const opt1 = document.createElement("option");
    opt1.value = v.name;
    opt1.textContent = v.name;
    kickVoiceSelect.appendChild(opt1);

    const opt2 = document.createElement("option");
    opt2.value = v.name;
    opt2.textContent = v.name;
    timerVoiceSelect.appendChild(opt2);
  });

  if (!kickVoiceName) kickVoiceName = voices[0].name;
  if (!twitchVoiceName) twitchVoiceName = voices[0].name; // Defaulting Twitch voice
  if (!timerVoiceName) timerVoiceName = voices[1]?.name || voices[0].name;

  kickVoiceSelect.value = kickVoiceName;
  if (timerVoiceSelect) timerVoiceSelect.value = timerVoiceName;
}

speechSynthesis.onvoiceschanged = loadVoices;
loadVoices();

/* ====== BOT FILTERING LOGIC ====== */
const KICK_BOTS = [
  "botrix", "kickbot", "kick", "streamelements", "nightbot", "moobot",
  "fossabot", "wizebot", "deepbot", "coebot", "phantombot", "ankhbot",
  "vivbot", "streamlabs", "cloudbot", "stay_hydrated_bot", "restreambot",
  "sery_bot", "commanderroot", "lurxx", "electricalskateboard",
  "electricallongboard", "alizeepathfinder", "virgoproz", "creatisbot",
  "slocool", "p0lizei_", "lolrankbot", "0ax2", "thepositivebot",
  "communityshowcase",
];

const isBot = (username) => {
  const lowerUsername = username.toLowerCase().trim();
  if (KICK_BOTS.includes(lowerUsername)) return true;
  if (lowerUsername.endsWith("bot") || 
      lowerUsername.endsWith("_bot") || 
      lowerUsername.includes("bot_")) {
    return true;
  }
  return false;
};

/* ====== KICK CONNECTION ====== */
let processedKickIds = new Set(); 

function connectKick() {
  try {
    const ws = new WebSocket(
      "wss://ws-us2.pusher.com/app/32cbd69e4b950bf97679?protocol=7&client=js&version=8.4.0-rc2&flash=false"
    );

    ws.onopen = () => console.log("Kick: Pusher connected");

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);

        if (data.event === "pusher:connection_established") {
          ws.send(JSON.stringify({
            event: "pusher:subscribe",
            data: { channel: `chatrooms.${savedKickID}.v2` } 
          }));
        }

        if (data.event === "App\\Events\\ChatMessageEvent") {
          const messageData = JSON.parse(data.data);
          const username = messageData.sender?.username || "Unknown";
          const messageId = messageData.id || `${Date.now()}-${Math.random()}`;
          
          if (processedKickIds.has(messageId)) return;
          if (isBot(username)) return;

          processedKickIds.add(messageId);
          if (processedKickIds.size > 1000) {
            processedKickIds = new Set(Array.from(processedKickIds).slice(-1000));
          }

          addMessage({
            id: `kick-${messageId}`,
            platform: "kick",
            username: username,
            message: messageData.content || "",
            timestamp: new Date(),
            color: "#53fc18"
          });
        }
      } catch (error) {
        // Silent catch for generic pusher messages
      }
    };

    ws.onerror = (error) => console.error("Kick WebSocket error:", error);
    ws.onclose = () => {
      console.log("Kick: Disconnected, reconnecting in 5s...");
      setTimeout(connectKick, 5000);
    };

  } catch (error) {
    console.error("Kick connection failed:", error);
    setTimeout(connectKick, 10000);
  }
}
connectKick();

/* ====== TWITCH CONNECTION ====== */
let processedTwitchIds = new Set(); 

function connectTwitch() {
  // We'll use the kick username as a fallback if they didn't save a twitch one
  const channelName = localStorage.getItem('jx_twitch_user') || savedKickUser; 
  if (!channelName) return;

  const ws = new WebSocket("wss://irc-ws.chat.twitch.tv:443");

  ws.onopen = () => {
    console.log(`Twitch: Connected to #${channelName.toLowerCase()}`);
    ws.send("CAP REQ :twitch.tv/tags twitch.tv/commands");
    ws.send("NICK justinfan12345"); // Anonymous connection to read chat
    ws.send(`JOIN #${channelName.toLowerCase()}`);
  };

  ws.onmessage = (event) => {
    const lines = event.data.split('\r\n');
    
    lines.forEach(line => {
      if (!line) return;
      
      // Keep connection alive
      if (line.startsWith("PING")) {
        ws.send("PONG :tmi.twitch.tv");
        return;
      }

      // Read Messages
      if (line.includes("PRIVMSG")) {
        const tagsPart = line.split(' ')[0];
        const userMatch = line.match(/:(\w+)!\w+@\w+\.tmi\.twitch\.tv PRIVMSG/);
        const msgMatch = line.match(/PRIVMSG #[^:]+:(.+)/);

        if (userMatch && msgMatch) {
          const username = userMatch[1];
          const message = msgMatch[1];
          
          // Get ID and filter bots
          let msgId = `${Date.now()}-${Math.random()}`;
          const idMatch = tagsPart.match(/@.*id=([^;]+)/);
          if (idMatch) msgId = idMatch[1];

          if (processedTwitchIds.has(msgId)) return;
          if (isBot(username)) return;

          processedTwitchIds.add(msgId);
          if (processedTwitchIds.size > 1000) {
            processedTwitchIds = new Set(Array.from(processedTwitchIds).slice(-1000));
          }

          addMessage({
            id: `twitch-${msgId}`,
            platform: "twitch",
            username: username,
            message: message,
            timestamp: new Date(),
            color: "#a970ff"
          });
        }
      }
    });
  };

  ws.onerror = (error) => console.error("Twitch WebSocket error:", error);
  ws.onclose = () => {
    console.log("Twitch: Disconnected, reconnecting in 5s...");
    setTimeout(connectTwitch, 5000);
  };
}
connectTwitch();


/* ====== CHAT / QUEUE ====== */
function addMessage(msg) {
  const div = document.createElement("div");
  div.className = "chat-line";
  const color = msg.color || "#ff7a18";
  div.innerHTML = `<span style="color:${color};font-weight:600">[${msg.platform}] ${msg.username}:</span> ${msg.message}`;
  chatLog.appendChild(div);
  chatLog.scrollTop = chatLog.scrollHeight;

  queue.push(msg);
  queueLen.textContent = queue.length;
}

/* ====== TTS PLAYBACK QUEUE SYSTEM ====== */
function processQueue() {
  if (!isPlaying || isMuted || isSpeaking || queue.length === 0 || !audioEnabled) {
    return;
  }

  const nextMessage = queue.shift(); 
  queueLen.textContent = queue.length;
  
  isSpeaking = true;
  speakingNow.textContent = `${nextMessage.username}: ${nextMessage.message}`;

  const textToSpeak = (readUsernameBox && readUsernameBox.checked) 
    ? `${nextMessage.username} says: ${nextMessage.message}`
    : nextMessage.message;

  const utterance = new SpeechSynthesisUtterance(textToSpeak);
  
  utterance.volume = volume;  
  utterance.rate = rate;      
  utterance.pitch = pitch;    
  
  let selectedVoiceName = "";
  if (nextMessage.platform === "twitch") {
    selectedVoiceName = twitchVoiceName || kickVoiceName;
  } else if (nextMessage.platform === "kick") {
    selectedVoiceName = kickVoiceName;
  } else if (nextMessage.platform === "timer") {
    selectedVoiceName = timerVoiceName;
  }
  
  const voice = voices.find((v) => v.name === selectedVoiceName);
  if (voice) {
    utterance.voice = voice;
  }

  utterance.onend = () => {
    isSpeaking = false;
    speakingNow.textContent = "None";
  };

  utterance.onerror = () => {
    isSpeaking = false;
    speakingNow.textContent = "None";
  };

  speechSynthesis.speak(utterance);
}

setInterval(processQueue, 100);

/* ====== MULTI TIMER ====== */
function renderTimers() {
  timersList.innerHTML = "";
  timers.forEach(t => {
    const div = document.createElement("div");
    div.className = "timer-item";
    const intervalSec = Math.round(t.intervalMs / 1000);
    div.innerHTML = `
      <div><strong style="color:#ff7a18;">${t.message}</strong></div>
      <div class="timer-meta">
        Every ${intervalSec} seconds<br>
        Last fired: ${t.lastFired ? new Date(t.lastFired).toLocaleTimeString() : "Never"}
      </div>
      <div style="margin-top:6px;">
        <button data-id="${t.id}" class="toggleTimerBtn">
          ${t.enabled ? "Disable" : "Enable"}
        </button>
        <button data-id="${t.id}" class="deleteTimerBtn">
          Delete
        </button>
      </div>
    `;
    timersList.appendChild(div);
  });

  document.querySelectorAll(".toggleTimerBtn").forEach(btn => {
    btn.onclick = () => {
      const id = btn.getAttribute("data-id");
      const timer = timers.find(t => t.id === id);
      if (!timer) return;
      timer.enabled = !timer.enabled;
      renderTimers();
    };
  });

  document.querySelectorAll(".deleteTimerBtn").forEach(btn => {
    btn.onclick = () => {
      const id = btn.getAttribute("data-id");
      timers = timers.filter(t => t.id !== id);
      renderTimers();
    };
  });
}

function addTimerFromUI() {
  timerError.textContent = "";

  if (timers.length >= 15) {
    timerError.textContent = "You already have 15 timers. Delete one to add another.";
    return;
  }

  const msg = (timerMessageInput.value || "").trim();
  if (!msg) {
    timerError.textContent = "Please enter a timer message.";
    return;
  }

  let intervalSec;
  const preset = timerPresetSelect.value;
  if (preset === "custom") {
    const custom = parseInt(customIntervalInput.value, 10);
    if (isNaN(custom) || custom <= 0) {
      timerError.textContent = "Custom interval must be a positive number of seconds.";
      return;
    }
    intervalSec = custom;
  } else {
    intervalSec = parseInt(preset, 10);
  }

  const timer = {
    id: "timer-" + Date.now() + "-" + Math.random(),
    message: msg,
    intervalMs: intervalSec * 1000,
    enabled: true,
    lastFired: 0
  };

  timers.push(timer);
  timerMessageInput.value = "";
  renderTimers();
}

timerPresetSelect.onchange = () => {
  if (timerPresetSelect.value === "custom") {
    customIntervalWrapper.style.display = "block";
  } else {
    customIntervalWrapper.style.display = "none";
  }
};

addTimerBtn.onclick = addTimerFromUI;

setInterval(() => {
  const now = Date.now();
  let uiNeedsUpdate = false;

  timers.forEach(t => {
    if (!t.enabled) return;
    
    if (!t.lastFired || now - t.lastFired >= t.intervalMs) {
      t.lastFired = now;
      uiNeedsUpdate = true;
      
      addMessage({
        platform: "timer",
        username: "Timer",
        message: t.message,
        id: t.id + "-" + now,
        color: "#00c8ff"
      });
    }
  });

  if (uiNeedsUpdate) {
    renderTimers();
  }
}, 500);

/* ====== UI EVENTS ====== */
enableAudioBtn.onclick = () => {
  audioEnabled = true;
  const starter = new SpeechSynthesisUtterance(" ");
  speechSynthesis.speak(starter);
  const u = new SpeechSynthesisUtterance("Audio enabled.");
  speechSynthesis.speak(u);
};

playPauseBtn.onclick = () => {
  isPlaying = !isPlaying;
  playPauseBtn.textContent = isPlaying ? "Pause" : "Play";
};

muteBtn.onclick = () => {
  isMuted = !isMuted;
  muteBtn.textContent = isMuted ? "Unmute" : "Mute";
};

testTtsBtn.onclick = () => {
  if (!audioEnabled) return alert("Enable audio first by clicking the Enable Audio button.");
  addMessage({
    platform: "kick",
    username: "System",
    message: "This is a Jailex TTS test.",
    id: "test-" + Date.now(),
    color: "#ff7a18"
  });
};

testTimerBtn.onclick = () => {
  addMessage({
    platform: "timer",
    username: "Timer",
    message: "Timer event fired.",
    id: "timer-" + Date.now(),
    color: "#00c8ff"
  });
};

kickVoiceSelect.onchange = () => kickVoiceName = kickVoiceSelect.value;
if (timerVoiceSelect) timerVoiceSelect.onchange = () => timerVoiceName = timerVoiceSelect.value;

volumeSlider.oninput = () => volume = parseFloat(volumeSlider.value);
rateSlider.oninput = () => rate = parseFloat(rateSlider.value);
pitchSlider.oninput = () => pitch = parseFloat(pitchSlider.value);
